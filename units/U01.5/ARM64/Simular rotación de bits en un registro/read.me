###############################################################################
#   â–‘â–ˆâ–€â–€â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–€â–„â–‘â–‘â–‘â–ˆâ–€â–€â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–€â–ˆâ–‘  â–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–„â–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–€â–„â–‘â–ˆâ–€â–ˆ
#   â–‘â–ˆâ–‘â–‘â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–‘â–‘â–ˆâ–€â–€â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘  â–‘â–ˆâ–€â–„â–‘â–ˆâ–€â–€â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–ˆ
#   â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–€â–‘â–‘â–‘â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–€â–‘â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘  â–‘â–€â–€â–‘â–‘â–€â–€â–€â–‘â–€â–€â–‘â–‘â–€â–€â–€â–‘â–€â–€â–‘â–‘â–€â–€â–€
#==============================================================================
# ğŸ§­ Asignatura : Lenguajes de Interfaz en TECNM Campus ITT  
# ğŸ§‘â€ğŸ’» Autor/a    : Juavier Lopez Prudencio  
# ğŸ“… Fecha      : 2025/09/25  
# ğŸ§¾ PropÃ³sito  : SimulaciÃ³n educativa que muestra la rotaciÃ³n de bits  
#                 (ROR / ROL) en ARM64 y su efecto sobre registros.  
# ğŸ”— SimulaciÃ³n : https://wokwi.com/projects/arm64-rol-ror-sim (editable)  
#------------------------------------------------------------------------------
#                             â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
#                             â•‘  âš™ï¸  NÃšCLEO RETRO-ARM  âš™ï¸ â•‘
#                             â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#------------------------------------------------------------------------------
# ğŸ›ï¸ Tema: Retro / Cyberpunk â€” laboratorio de bits y ensamblador ARM64  
#
# âœ¨ "Gira el registro, revela secretos: domina el flujo de bits."  
# ğŸ·ï¸ MÃ³dulo: CrÃ³nicas del Ensamblador â€” Vol. I: Giros del Silicio  
###############################################################################

# RotaciÃ³n de bits en ARM64 â€” CÃ³digo comentado y explicaciÃ³n

Autor: Lopez Prudencio Javier
Fecha: 2025-09-25
DescripciÃ³n: VersiÃ³n comentada y explicada del programa ARM64 que escribe un mensaje a stdout usando syscalls (sin printf).

---

## CÃ³digo original comentado (lÃ­nea a lÃ­nea)

```asm
    .data
msg:    .asciz "Resultado: 0x12345678 rotado: 0x78123456\n"

    .text
    .global _start

_start:
    // -----------------------------
    // 1. Preparar mensaje
    // -----------------------------
    ldr x1, =msg          // x1 <- direcciÃ³n del comienzo de la cadena 'msg'
    mov x0, #1           // x0 <- file descriptor 1 (stdout)
    mov x2, 43           // x2 <- longitud del mensaje en bytes (AQUI HAY UN DETALLE, ver explicaciÃ³n)
    mov x8, #64          // x8 <- nÃºmero de syscall: 64 = write (en Linux aarch64)
    svc 0                // invoca la syscall (es equivalente a 'syscall' en otras arquitecturas)

    // -----------------------------
    // 2. Salir del programa
    // -----------------------------
    mov x0, #0           // x0 <- cÃ³digo de salida 0
    mov x8, #93          // x8 <- nÃºmero de syscall: 93 = exit (en Linux aarch64)
    svc 0                // invoca la syscall exit
```

---

## ExplicaciÃ³n detallada

* `.data` / `.text`: secciones del binario. `.data` contiene datos estÃ¡ticos (la cadena), `.text` contiene cÃ³digo ejecutable.
* `msg: .asciz "..."`: define una cadena ASCII terminada en `\0`. La `\n` dentro de la cadena es un salto de lÃ­nea.
* `ldr x1, =msg`: pseudo-instrucciÃ³n que el ensamblador traduce a la forma apropiada para cargar la **direcciÃ³n** de `msg` en el registro `x1`. En AArch64, esto suele expandirse a `adrp` + `add` si la direcciÃ³n estÃ¡ lejos.
* Registros usados para las syscalls en Linux AArch64:

  * `x8` contiene el nÃºmero de syscall.
  * `x0`, `x1`, `x2`, ... contienen argumentos de la syscall.
  * Para `write` (syscall 64):

    * `x0` = file descriptor (1 = stdout)
    * `x1` = puntero al buffer
    * `x2` = longitud en bytes
  * Para `exit` (syscall 93):

    * `x0` = exit code
* `svc 0`: provoca la entrada en modo supervisor para ejecutar la syscall.

---

## Problema detectado: longitud del mensaje

En el cÃ³digo original la instrucciÃ³n `mov x2, 43` pretende establecer la longitud del mensaje a 43 bytes, pero la cadena real:

```
"Resultado: 0x12345678 rotado: 0x78123456\n"
```

tiene **41 bytes** (incluyendo el `\n`, pero sin contar el terminador nulo `\0` que `.asciz` coloca al final). Usar una longitud incorrecta puede provocar que la syscall `write` lea bytes basura o muestre menos/mas caracteres de los esperados.

---

## Formas recomendadas para fijar la longitud (robusto)

1. Calcular la longitud en tiempo de ensamblado usando el ensamblador:

```asm
    .data
msg:    .asciz "Resultado: 0x12345678 rotado: 0x78123456\n"
msg_len = . - msg
```

y luego en el cÃ³digo:

```asm
    ldr x1, =msg
    ldr x2, =msg_len
```

Nota: algunos ensambladores no permiten `ldr x2, =msg_len` con un inmediato grande; otra opciÃ³n es usar una pseudo-instrucciÃ³n como `mov x2, #<valor>` si el valor cabe.

2. Poner la longitud explÃ­cita corregida (simple) si conoces el tamaÃ±o:

```asm
    mov x2, #41
```

---

## VersiÃ³n corregida y recomendada (compacta)

```asm
    .data
msg:    .asciz "Resultado: 0x12345678 rotado: 0x78123456\n"
msg_len = . - msg

    .text
    .global _start

_start:
    // preparar argumentos para write
    ldr x1, =msg          // puntero al buffer
    mov x0, #1            // stdout
    mov x2, #41           // longitud correcta en bytes (alternativa: cargar msg_len)
    mov x8, #64           // syscall write
    svc 0

    // exit
    mov x0, #0            // exit code 0
    mov x8, #93           // syscall exit
    svc 0
```

> ObservaciÃ³n: si prefieres que el ensamblador calcule `msg_len` y lo cargue automÃ¡ticamente en `x2`, podrÃ­as usar macros o soluciones especÃ­ficas del ensamblador (por ejemplo, `.equ` o `ldr` con la etiqueta de tamaÃ±o). Si vas a compilar para sistemas donde las direcciones pueden ser grandes (p. ej. PIE), usa `adrp`/`add` generadas por `ldr x1, =msg` y similar.

---

## Comentarios finales

* Este programa solo imprime un texto estÃ¡tico; no realiza la rotaciÃ³n real de 0x12345678 en tiempo de ejecuciÃ³n. El texto muestra un ejemplo de rotaciÃ³n (0x12345678 rotado a 0x78123456), pero la operaciÃ³n numÃ©rica no se realiza en el cÃ³digo proporcionado.
* Si quieres que el programa calcule la rotaciÃ³n en un registro y la imprima (por ejemplo, convertir el valor a hexadecimal y escribirlo), eso requiere implementar una rutina de conversiÃ³n de entero a ASCII o enlazar con `printf` (lo cual complica el ejemplo al requerir la ABI y llamadas a librerÃ­as). Puedo ayudarte a:

  * Crear la versiÃ³n que calcule la rotaciÃ³n en registros y la deje en `x0/x1` (sin imprimir), o
  * Crear una versiÃ³n que convierta el resultado a ASCII y lo escriba por `write`, o
  * Hacer una versiÃ³n que use `printf` (requiere enlazar con libc).

Â¿CuÃ¡l de estas opciones prefieres? Si quieres, te genero el cÃ³digo ensamblador completo listo para compilar con `gcc`/`as`.


